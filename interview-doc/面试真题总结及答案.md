# 1 阿里巴巴一轮电话面试:
## 1.1 hashMap部分

问：hashmap的数据结构是怎样的？<br>
答：hashmap的数据结构为数组+链表，通过计算hash值并将其放入映射的桶里，
如果该桶内已存在元素，则以链表的形式存放；

问：hash值如何映射在桶里的？
答：根据hash算法的介绍，可以把hash值除以桶长度取余数，hashmap的实际做法是先把hash值的高八位与低八位混合，再配以扰动函数，最后对hashmap的桶长度-1后进行与运算，因为hashmap的长度是2的幂次方，减一后以2进制所有的位数都是1，做与运算时不存在绝对的空区，这样就能保证元素在桶内的均匀分布；

问：调用put方法时元素是怎样放置的
答：hashmap存放的元素都是包含key-value键值对的entry对象，在存放时首先根据key的hash值映射到对应的桶位置，如果这个位置没有其他的entry对象，就直接放在这个位置，如果有其他的entry就以链表的形式存放；
补充：这里其实还可以说明如果有其他的entry，会调用equals方法循环链表进行比较，如果遇到相同的key，就把这个entry元素的value覆盖，否则就加入这个链表。

问：调用get方法时元素是怎样查找的
答：根据key的hash值映射到对应的桶位置，然后循环这个位置放置的链表，调用equals方法进行比较，当equals方法返回true时，就从这个entry取返回值。

问：描述一下在极端的情况下，hashmap的时间复杂度
答：在发生严重的哈希碰撞时，几乎所有的entry元素都集中在同一个桶的链表里，这时数组+链表的结构退化为单纯的链表，时间复杂度为O(n)

问：有什么优化策略吗
答：如果要避免这种情况可以只使用数组，用空位探测法替代链接结构，但是由于聚集现象，这种结构反而不如数组+链接的结构健壮。

问：再想想其他的优化方式
答：对了，可以使用树代替链表，比如红黑树

问：优化后的时间复杂度是多少呢
答：因为红黑树是平衡的二叉树，所以时间复杂度能降为O(logN)

问：你了解过jdk1.8对hashmap作了哪些优化吗
答：因为我们目前的开发用的都是jdk1.7，所以还没研究过
补充：jdk1.8对hashmap的优化为当链表的长度达到8时，会将链表自动转换为红黑树
面试官：你可以去了解下（hashmap部分结束）

Hashmap面试总结：除上述面试内容之外，面试官还可能提的问题有初始化桶容量和负载因子的选取、hashmap选取桶长度的策略，以及重桶长度的重新计算、扰动函数的作用等内容，这些知识点可参考Hashmap源码和《java数据结构和算法》一书。

## 1.2 红黑树部分
问：刚才你提到用红黑树优化链表，可以介绍一下黑红树吗，它是如何维持平衡的
答：红黑树是一种特殊的二叉树，跟普通二叉树一样采用二分查找的方式；
普通二叉树在不平衡的情况下会影响查找效率，在极端情况下会退化为链表，红黑树恰好解决了普通二叉树不平衡的问题。红黑树维持平衡主要依靠它的第五条性质：从任意节点到它的任意叶节点的路径黑高相同。

问：黑高？
答：嗯，就是路径上黑色节点的数目。

面试官：继续
答：为满足这条性质，当红黑树新增节点导致不平衡时，可以通过节点变色和局部旋转来满足红黑树的规则。比如插入的节点的父节点是黑色时，不影响平衡，插入的父节点是红色且叔叔节点也是红色时，把父节点和叔叔节点涂黑，把祖父节点涂红，然后把祖父节点单做新插入的节点依次类推。

面试官：嗯，好（黑红树部分结束）

面试总结：除大概介绍外，面试官还可能问及红黑树的五条具体性质，以及各种插入和删除时对应的变色和旋转策略。具体可参考下面的文档（这篇文章应该算介绍红黑树系列中错误率较少且比较容易理解的一篇了）：
https://blog.csdn.net/Sun_TTTT/article/details/65445754






## 1.3 ThreadLocal部分
问：你有使用过ThreadLocal吗
答：有的，在之前一个项目中编写分页插件时有到过，在调用数据库查询接口前把分页信息存储在ThreadLocal类型的静态变量里，在拦截数据库会话器时取得sql和ThreadLocal中的分页信息，用于拼接sql。

问：那么移除ThreadLocal的信息是在什么时候进行呢
答：当sql拼接好之后就移除当前线程的分页信息。

问：在查询之前设置分页信息是写在业务代码里的吧，这样写有些奇怪，没有考虑用其他的方式吗，比如传参
答：之前是有考虑的，但是设置在ThreadLocal一方面是不需要在拦截器里获取参数，还有一方面就是作为不分页的查询跟分页查询的区分。用参数的话也可以，但是取名方面得注意不能跟其他的业务参数相冲突。

问：那考虑过用注解吗
答：之前用考虑过用注解的方式生成代理，但是service层的对象本身在设置事务时本身就是由spring创建的代理对象，在这基础上创建代理可能兼容比较麻烦。

问：ThreadLocal的实现原理有了解过吗
答：只知道ThreadLocal的本质是空间换时间，通过为每个线程开辟一块独立空间，达到线程间的相互隔离。可以通过当前线程去存储或者取出相应的对象。

问：那么ThreadLocal的数据结构呢
答：这个还没研究过
补充：ThreadLocal类的实现方式是在每个线程中缓存一个内部类对象，这个内部类对象实现了一个散列表的数据结构，参考：
https://zhuanlan.zhihu.com/p/31479366

##1.4 线程池部分
问：你的简历里提到过线程池，是jdk的线程池吗？
答：是spring的，但是spring的线程池只是在jdk线程池的基础上做了简单的封装。

问：你介绍一下线程池的参数有哪些，分别的作用呢
答：核心线程数：指定核心活跃线程数数量，在任务数量未超过核心线程数仍然保持这个数目的线程；
最大线程数：当任务数超过核心线程数时，系统中的线程数能增加到的最大数目；
线程存活时间：当线程数超过核心线程数时，闲置的线程能存活的最长时间；
线程池的拒绝策略：当任务数大于最大线程数时，可以选择抛出异常或者由主线程直接执行该任务；

问：既然是执行任务，那肯定有任务队列的吧
答：有的，这个参数设置一般设置Integer的最大值

问：现设置核心线程数10，最大线程数30，任务队列数10，线程活跃时间很长，当任务数超过11时会怎么样
答：这种情况没遇到过，应该是会抛出异常？（很自信的猜了一把）
面试官：如果是抛出异常的话，最大线程数的设置就没有意义了（指出错误，线程池部分结束）
补充：实际上任务队列数是指排队等待的任务数，任务数超过最大线程数时才需要排队等待，当任务数>最大线程数+任务队列数时根据拒绝策略选择主线程执行或者抛出异常。参考：
https://blog.csdn.net/langwang2/article/details/50194057

面试总结：这个部分有点丢分，因为是简历中提到的技术应该要比面试官随口问的技术更能拿出手，如果没有深入的理解难以显示出功底的扎实，建议只是停留在应用层面的技术不要写在简历上。

##1.5 spring aop实现原理部分
问：描述一下spring aop的原理
答：spring aop实现的关键是spring创建的代理，通过使用者自定义切点和增强，框架通过或者这些自定义的信息创建动态代理，将增强织入目标类，一般用于日志、缓存和事务管理等方面；

问：那么代理是如何创建的呢
答：一般通过jdk或者cglib创建（转入下个部分）

##1.6 动态代理部分
问：那么jdk代理和cglib代理在使用上的区别呢
答：jdk的基于接口的代理，cglib是基于类的代理，在类没有实现接口时，spring会选择cglib创建代理，在类有实现接口时，spring默认选用jdk创建代理，但是用户可以手动设置使用cglib创建代理。

问：那么除了cglib是基于类的代理，jdk是基于接口的代理，这两种代理还有其他的区别吗
答：一个创建速度较快，一个执行速度较快

问：那个创建速度快，哪个执行速度快呢
答：cglib创建代理速度快，jdk代理执行速度快（答反了，对原理理解不够导致）

问：确定吗
答：确定（犹豫了一下）
面试官：ok（动态代理部分结束）
补充：一般认为cglib创建代理速度慢，但运行速度快，下面有篇文章提供两种代理的测试结果：https://www.aliyun.com/jiaocheng/577153.html
但也有文章反驳jdk7以上的动态代理执行速度较快：
https://blog.csdn.net/bigtree_3721/article/details/50833812

##1.7 restful架构部分
问：你介绍的其中两个项目介绍的框架基本一致，只有resteasy和spring mvc的区别，是用resteasy代替spring mvc吗
答：是的，只有restful框架发生了变化

问：能说一下resteasy和spring mvc的区别吗
答：resteasy跟jboss容器是无缝对接的，配置较少，在业务开发上resteasy和spring mvc是差不多的，只是注解名称不一样，功能上没有太多区别

问：也就是说因为你们的容器换成了jboss，所以才选用resteasy吗
答：是的（restful架构部分结束）

面试总结：这个部分的资料较少，对应用之外的原理了解不多，只能迅速跳过。据网上的介绍说resteasy相比spring mvc而言更加专注和简单，而spring mvc相对于大型系统更有优势。具体可参考：
http://www.mamicode.com/info-detail-1815683.html

##1.8 jvm部分
问：jvm的内存模型有了解过吗
答：jvm由线程共享的部分有堆和方法区，线程隔离的部分有线程计数器，java虚拟机栈和本地方法栈，但用的最广泛的hotspot虚拟机是将java虚拟机栈和本地方法栈合二为一的。

问：那么堆又分为哪几块呢
答：分为新生代、年老代和永久代，其中新生代又分为1和Eden区和两个survivor区，新创建的对象都在Eden区，在垃圾回收时采用复制算法将Eden区和一个survivor区的不回收对象复制到另一个survivor区，两个survivor区轮流备份对象数据，在survivor区多次未回收的对象将会被放入年老代

问：你有处理过内存泄露的问题吗
答：在实际项目中没有遇到过，只有自己在单测中循环创建对象加入集合，达到内存泄露的条件
面试官：好，你的情况我基本了解了，你有哪些想要了解的吗（jvm部分结束）

补充：jvm的考点较多就不划重点了，可以自行参考《深入理解java虚拟机 JVM高级特性与最佳实践》，垃圾回收流程另有一篇配合图解的csdn博客：
https://blog.csdn.net/lojze_ly/article/details/49456255


# 2宇信科技集团二轮技术面试
## 2.1 ascll码排序部分
问：现在在java中有10000条数据，如何通过ascII码排序
答：用Collections.sort方法，比较器里取出value的char数组，然后遍历char数组的每一个char的大小进行比较

问：还有其他的排序方式吗
答：暂时没想到了

## 2.2 红黑树部分
问：你了解过红黑树吗
答：。。。（过程与1.2部分基本一致）

问：红黑树是不是可以做我们刚才说的ascII码排序
答：可以的

补充：java实现红黑树的类有TreeMap, TreeSet等，ascII排序具体可参考
https://zhidao.baidu.com/question/482052304.html
## 2.3哈希算法部分
问：重写hashcode方法时如何避免哈希碰撞
答：可以取用对象的唯一信息计算hash值，比如在用户对象里，可以取用户名的字符串计算hash值，这样产生的hash值不容易重复，在hash值映射前可参考hashmap源码中的扰动函数，混合hash值的高8位与低8位，这样能尽可能保证不同的hash值映射到不同的桶区域。

问：你刚才说的是hash值不同的情况，那么在hash值相同的情况下呢，不管你怎么扰动都会在同一区域内，这种情况如何优化呢
答：这个暂时没想到
补充：这里可以答以红黑树代替链表，具体参考1.1部分（那时经过面试官提示回答出来了）

## 2.4事务部分
问：你们这边用mybatis框架，事务是用的mybatis的吗
答：事务只有单独使用mybatis的时候才使用jdbc事务，一般情况下我们用的是spring的事务。

问：事务的级别有哪些呢
答：有读未提交，读已提交，重复读，序列化，安全性从低到高，我们一般默认读已提交的方式
补充：事务隔离级别的参考资料：https://blog.csdn.net/qq_33290787/article/details/51924963

问：那创建的事务有哪几种呢（这里问的是事务的传播方式）
答：比如？（没理解题意）
面试官：像REQUIRES, REQUIRES_NEW
答：事务的传播方式总共有七种，默认是 REQUIRES_NEW
7中传播方式功能分别是：如果有事务就支持，没有事务就在没有事务的情况下执行；
还有一种是如果有事务就支持，没有就新建，这个是默认的；
另一种是有事务就支持，没有事务抛出异常；
第四种是只能在无事务情况下执行，如果有事务就抛出异常；
第五种是有事务就支持，没有事务也不新建，剩下的记不清了，只知道一共7种（这里意识到重复了）
补充：Spring的7中传播行为可参考：
https://blog.csdn.net/hsgao_water/article/details/52860380

问：你读过spring事务部分的源码吗
答：看过一些基础架构，它是基于spring aop的，通过spring aop创建代理，在代理的拦截方法中捕获执行方法的异常，如果捕获到异常可以进行相应的回滚

问：你知道spring捕获异常之后做了哪些操作吗
答：如果有运行时异常就进行回滚，也可以在事务注解的参数里自定义其他的异常进行回滚，回滚最终调用的是Connection的rollback方法。

问：还有其他的吗
答：就知道这些了

补充：spring事务部分可参考spring源码，相应的参考书籍有《spring源码深度解析》


## 2.5 jvm部分
这个部分问到了jvm内存模型与垃圾回收，提问和回答基本与1.8部分的前两个问题完全一致，故不再复述


## 2.6 volitile变量
问：你了解过volitile变量吗
答：在设计模式的介绍中见过，单例模式的双重加锁方式中单例变量需要用到这个修饰符；
补充：可参考http://www.cnblogs.com/java-my-life/archive/2012/03/31/2425631.html

问：它的作用你知道吗
答：防止指令重排序，对所有线程立即可见

问：在高并发的情况下可以用这个变量吗
答：高并发情况下我们一般使用锁来实现，这个变量用的比较少，主要对于一些布尔变量进行修饰，因为布尔变量的赋值是原子性的，而volitile用能防止虚拟机做性能优化时的指令重排序，这种情况下是可以使用的。
面试官：你刚才提到的指令重排序这点很好，但是用volitile修饰的变量是所有现场都可以同时修改的，所以高并发情况下volitile是不能使用的。（这点貌似对赋值原子性的变量不适用）

## 2.7 mybatis部分
 由于时间原因本章及后续内容以后再补充，本部分的mybatis执行流程和各对象的生命周期可参考《深入浅出mybatis技术原理与实战》

## 2.8 redis部分

## 2.9 tcp等底层协议部分

## 2.10 线程池部分


#参考
参考书籍下载地址（永久有效）：
《java数据结构和算法》：
链接：https://pan.baidu.com/s/1Oru4u2Hn-V8pGwMq4flLPQ 密码：j4le

《spring源码深度解析》：
链接：https://pan.baidu.com/s/17bua_vTYah0HDmgULjDF-w 密码：u3s6

《深入理解java虚拟机 JVM高级特性与最佳实践》：
链接：https://pan.baidu.com/s/13u5h9r_lVlM_4RPpFscILg 密码：cz78

《深入浅出mybatis技术原理与实战》：
链接：https://pan.baidu.com/s/16_rm-rMzNSXZH0Mhkt4VhA 密码：ihyl